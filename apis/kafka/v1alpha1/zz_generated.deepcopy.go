//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdviceIdsInitParameters) DeepCopyInto(out *AdviceIdsInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdviceIdsInitParameters.
func (in *AdviceIdsInitParameters) DeepCopy() *AdviceIdsInitParameters {
	if in == nil {
		return nil
	}
	out := new(AdviceIdsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdviceIdsObservation) DeepCopyInto(out *AdviceIdsObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(float64)
		**out = **in
	}
	if in.Params != nil {
		in, out := &in.Params, &out.Params
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdviceIdsObservation.
func (in *AdviceIdsObservation) DeepCopy() *AdviceIdsObservation {
	if in == nil {
		return nil
	}
	out := new(AdviceIdsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AdviceIdsParameters) DeepCopyInto(out *AdviceIdsParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AdviceIdsParameters.
func (in *AdviceIdsParameters) DeepCopy() *AdviceIdsParameters {
	if in == nil {
		return nil
	}
	out := new(AdviceIdsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AssignmentInitParameters) DeepCopyInto(out *AssignmentInitParameters) {
	*out = *in
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.PartitionBrokers != nil {
		in, out := &in.PartitionBrokers, &out.PartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AssignmentInitParameters.
func (in *AssignmentInitParameters) DeepCopy() *AssignmentInitParameters {
	if in == nil {
		return nil
	}
	out := new(AssignmentInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AssignmentObservation) DeepCopyInto(out *AssignmentObservation) {
	*out = *in
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.PartitionBrokers != nil {
		in, out := &in.PartitionBrokers, &out.PartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AssignmentObservation.
func (in *AssignmentObservation) DeepCopy() *AssignmentObservation {
	if in == nil {
		return nil
	}
	out := new(AssignmentObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AssignmentParameters) DeepCopyInto(out *AssignmentParameters) {
	*out = *in
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.PartitionBrokers != nil {
		in, out := &in.PartitionBrokers, &out.PartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AssignmentParameters.
func (in *AssignmentParameters) DeepCopy() *AssignmentParameters {
	if in == nil {
		return nil
	}
	out := new(AssignmentParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CauseIdsInitParameters) DeepCopyInto(out *CauseIdsInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CauseIdsInitParameters.
func (in *CauseIdsInitParameters) DeepCopy() *CauseIdsInitParameters {
	if in == nil {
		return nil
	}
	out := new(CauseIdsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CauseIdsObservation) DeepCopyInto(out *CauseIdsObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(float64)
		**out = **in
	}
	if in.Params != nil {
		in, out := &in.Params, &out.Params
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CauseIdsObservation.
func (in *CauseIdsObservation) DeepCopy() *CauseIdsObservation {
	if in == nil {
		return nil
	}
	out := new(CauseIdsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CauseIdsParameters) DeepCopyInto(out *CauseIdsParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CauseIdsParameters.
func (in *CauseIdsParameters) DeepCopy() *CauseIdsParameters {
	if in == nil {
		return nil
	}
	out := new(CauseIdsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigsInitParameters) DeepCopyInto(out *ConfigsInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigsInitParameters.
func (in *ConfigsInitParameters) DeepCopy() *ConfigsInitParameters {
	if in == nil {
		return nil
	}
	out := new(ConfigsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigsObservation) DeepCopyInto(out *ConfigsObservation) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigsObservation.
func (in *ConfigsObservation) DeepCopy() *ConfigsObservation {
	if in == nil {
		return nil
	}
	out := new(ConfigsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ConfigsParameters) DeepCopyInto(out *ConfigsParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ConfigsParameters.
func (in *ConfigsParameters) DeepCopy() *ConfigsParameters {
	if in == nil {
		return nil
	}
	out := new(ConfigsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CrossVPCAccessesInitParameters) DeepCopyInto(out *CrossVPCAccessesInitParameters) {
	*out = *in
	if in.AdvertisedIP != nil {
		in, out := &in.AdvertisedIP, &out.AdvertisedIP
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CrossVPCAccessesInitParameters.
func (in *CrossVPCAccessesInitParameters) DeepCopy() *CrossVPCAccessesInitParameters {
	if in == nil {
		return nil
	}
	out := new(CrossVPCAccessesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CrossVPCAccessesObservation) DeepCopyInto(out *CrossVPCAccessesObservation) {
	*out = *in
	if in.AdvertisedIP != nil {
		in, out := &in.AdvertisedIP, &out.AdvertisedIP
		*out = new(string)
		**out = **in
	}
	if in.LisenterIP != nil {
		in, out := &in.LisenterIP, &out.LisenterIP
		*out = new(string)
		**out = **in
	}
	if in.ListenerIP != nil {
		in, out := &in.ListenerIP, &out.ListenerIP
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.PortID != nil {
		in, out := &in.PortID, &out.PortID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CrossVPCAccessesObservation.
func (in *CrossVPCAccessesObservation) DeepCopy() *CrossVPCAccessesObservation {
	if in == nil {
		return nil
	}
	out := new(CrossVPCAccessesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CrossVPCAccessesParameters) DeepCopyInto(out *CrossVPCAccessesParameters) {
	*out = *in
	if in.AdvertisedIP != nil {
		in, out := &in.AdvertisedIP, &out.AdvertisedIP
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CrossVPCAccessesParameters.
func (in *CrossVPCAccessesParameters) DeepCopy() *CrossVPCAccessesParameters {
	if in == nil {
		return nil
	}
	out := new(CrossVPCAccessesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DestinationTaskInitParameters) DeepCopyInto(out *DestinationTaskInitParameters) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.SecretKeySecretRef != nil {
		in, out := &in.SecretKeySecretRef, &out.SecretKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.StoreKeys != nil {
		in, out := &in.StoreKeys, &out.StoreKeys
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DestinationTaskInitParameters.
func (in *DestinationTaskInitParameters) DeepCopy() *DestinationTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(DestinationTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DestinationTaskObservation) DeepCopyInto(out *DestinationTaskObservation) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.FlushSize != nil {
		in, out := &in.FlushSize, &out.FlushSize
		*out = new(float64)
		**out = **in
	}
	if in.KeyConverter != nil {
		in, out := &in.KeyConverter, &out.KeyConverter
		*out = new(string)
		**out = **in
	}
	if in.KvDelimiter != nil {
		in, out := &in.KvDelimiter, &out.KvDelimiter
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPartSize != nil {
		in, out := &in.ObsPartSize, &out.ObsPartSize
		*out = new(float64)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.PartitionerClass != nil {
		in, out := &in.PartitionerClass, &out.PartitionerClass
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.SchemaGeneratorClass != nil {
		in, out := &in.SchemaGeneratorClass, &out.SchemaGeneratorClass
		*out = new(string)
		**out = **in
	}
	if in.StoreKeys != nil {
		in, out := &in.StoreKeys, &out.StoreKeys
		*out = new(bool)
		**out = **in
	}
	if in.Timezone != nil {
		in, out := &in.Timezone, &out.Timezone
		*out = new(string)
		**out = **in
	}
	if in.ValueConverter != nil {
		in, out := &in.ValueConverter, &out.ValueConverter
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DestinationTaskObservation.
func (in *DestinationTaskObservation) DeepCopy() *DestinationTaskObservation {
	if in == nil {
		return nil
	}
	out := new(DestinationTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DestinationTaskParameters) DeepCopyInto(out *DestinationTaskParameters) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.AgencyName != nil {
		in, out := &in.AgencyName, &out.AgencyName
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.SecretKeySecretRef != nil {
		in, out := &in.SecretKeySecretRef, &out.SecretKeySecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.StoreKeys != nil {
		in, out := &in.StoreKeys, &out.StoreKeys
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DestinationTaskParameters.
func (in *DestinationTaskParameters) DeepCopy() *DestinationTaskParameters {
	if in == nil {
		return nil
	}
	out := new(DestinationTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisDimensionListInitParameters) DeepCopyInto(out *DiagnosisDimensionListInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisDimensionListInitParameters.
func (in *DiagnosisDimensionListInitParameters) DeepCopy() *DiagnosisDimensionListInitParameters {
	if in == nil {
		return nil
	}
	out := new(DiagnosisDimensionListInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisDimensionListObservation) DeepCopyInto(out *DiagnosisDimensionListObservation) {
	*out = *in
	if in.AbnormalNum != nil {
		in, out := &in.AbnormalNum, &out.AbnormalNum
		*out = new(float64)
		**out = **in
	}
	if in.DiagnosisItemList != nil {
		in, out := &in.DiagnosisItemList, &out.DiagnosisItemList
		*out = make([]DiagnosisItemListObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.FailedNum != nil {
		in, out := &in.FailedNum, &out.FailedNum
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisDimensionListObservation.
func (in *DiagnosisDimensionListObservation) DeepCopy() *DiagnosisDimensionListObservation {
	if in == nil {
		return nil
	}
	out := new(DiagnosisDimensionListObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisDimensionListParameters) DeepCopyInto(out *DiagnosisDimensionListParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisDimensionListParameters.
func (in *DiagnosisDimensionListParameters) DeepCopy() *DiagnosisDimensionListParameters {
	if in == nil {
		return nil
	}
	out := new(DiagnosisDimensionListParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisItemListInitParameters) DeepCopyInto(out *DiagnosisItemListInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisItemListInitParameters.
func (in *DiagnosisItemListInitParameters) DeepCopy() *DiagnosisItemListInitParameters {
	if in == nil {
		return nil
	}
	out := new(DiagnosisItemListInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisItemListObservation) DeepCopyInto(out *DiagnosisItemListObservation) {
	*out = *in
	if in.AdviceIds != nil {
		in, out := &in.AdviceIds, &out.AdviceIds
		*out = make([]AdviceIdsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.BrokerIds != nil {
		in, out := &in.BrokerIds, &out.BrokerIds
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.CauseIds != nil {
		in, out := &in.CauseIds, &out.CauseIds
		*out = make([]CauseIdsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.FailedPartitions != nil {
		in, out := &in.FailedPartitions, &out.FailedPartitions
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.Result != nil {
		in, out := &in.Result, &out.Result
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisItemListObservation.
func (in *DiagnosisItemListObservation) DeepCopy() *DiagnosisItemListObservation {
	if in == nil {
		return nil
	}
	out := new(DiagnosisItemListObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DiagnosisItemListParameters) DeepCopyInto(out *DiagnosisItemListParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DiagnosisItemListParameters.
func (in *DiagnosisItemListParameters) DeepCopy() *DiagnosisItemListParameters {
	if in == nil {
		return nil
	}
	out := new(DiagnosisItemListParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDelete) DeepCopyInto(out *KafkaBackgroundTaskDelete) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDelete.
func (in *KafkaBackgroundTaskDelete) DeepCopy() *KafkaBackgroundTaskDelete {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDelete)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaBackgroundTaskDelete) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteInitParameters) DeepCopyInto(out *KafkaBackgroundTaskDeleteInitParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteInitParameters.
func (in *KafkaBackgroundTaskDeleteInitParameters) DeepCopy() *KafkaBackgroundTaskDeleteInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteList) DeepCopyInto(out *KafkaBackgroundTaskDeleteList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaBackgroundTaskDelete, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteList.
func (in *KafkaBackgroundTaskDeleteList) DeepCopy() *KafkaBackgroundTaskDeleteList {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaBackgroundTaskDeleteList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteObservation) DeepCopyInto(out *KafkaBackgroundTaskDeleteObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteObservation.
func (in *KafkaBackgroundTaskDeleteObservation) DeepCopy() *KafkaBackgroundTaskDeleteObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteParameters) DeepCopyInto(out *KafkaBackgroundTaskDeleteParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteParameters.
func (in *KafkaBackgroundTaskDeleteParameters) DeepCopy() *KafkaBackgroundTaskDeleteParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteSpec) DeepCopyInto(out *KafkaBackgroundTaskDeleteSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteSpec.
func (in *KafkaBackgroundTaskDeleteSpec) DeepCopy() *KafkaBackgroundTaskDeleteSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaBackgroundTaskDeleteStatus) DeepCopyInto(out *KafkaBackgroundTaskDeleteStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaBackgroundTaskDeleteStatus.
func (in *KafkaBackgroundTaskDeleteStatus) DeepCopy() *KafkaBackgroundTaskDeleteStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaBackgroundTaskDeleteStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroup) DeepCopyInto(out *KafkaConsumerGroup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroup.
func (in *KafkaConsumerGroup) DeepCopy() *KafkaConsumerGroup {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConsumerGroup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupInitParameters) DeepCopyInto(out *KafkaConsumerGroupInitParameters) {
	*out = *in
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupInitParameters.
func (in *KafkaConsumerGroupInitParameters) DeepCopy() *KafkaConsumerGroupInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupList) DeepCopyInto(out *KafkaConsumerGroupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConsumerGroup, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupList.
func (in *KafkaConsumerGroupList) DeepCopy() *KafkaConsumerGroupList {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConsumerGroupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupObservation) DeepCopyInto(out *KafkaConsumerGroupObservation) {
	*out = *in
	if in.CoordinatorID != nil {
		in, out := &in.CoordinatorID, &out.CoordinatorID
		*out = new(float64)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Lag != nil {
		in, out := &in.Lag, &out.Lag
		*out = new(float64)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupObservation.
func (in *KafkaConsumerGroupObservation) DeepCopy() *KafkaConsumerGroupObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupParameters) DeepCopyInto(out *KafkaConsumerGroupParameters) {
	*out = *in
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupParameters.
func (in *KafkaConsumerGroupParameters) DeepCopy() *KafkaConsumerGroupParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupSpec) DeepCopyInto(out *KafkaConsumerGroupSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupSpec.
func (in *KafkaConsumerGroupSpec) DeepCopy() *KafkaConsumerGroupSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupStatus) DeepCopyInto(out *KafkaConsumerGroupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupStatus.
func (in *KafkaConsumerGroupStatus) DeepCopy() *KafkaConsumerGroupStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDelete) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDelete) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDelete.
func (in *KafkaConsumerGroupTopicBatchDelete) DeepCopy() *KafkaConsumerGroupTopicBatchDelete {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDelete)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConsumerGroupTopicBatchDelete) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteInitParameters) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteInitParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteInitParameters.
func (in *KafkaConsumerGroupTopicBatchDeleteInitParameters) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteList) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaConsumerGroupTopicBatchDelete, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteList.
func (in *KafkaConsumerGroupTopicBatchDeleteList) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteList {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaConsumerGroupTopicBatchDeleteList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteObservation) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteObservation) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Result != nil {
		in, out := &in.Result, &out.Result
		*out = make([]ResultObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteObservation.
func (in *KafkaConsumerGroupTopicBatchDeleteObservation) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteParameters) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteParameters.
func (in *KafkaConsumerGroupTopicBatchDeleteParameters) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteSpec) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteSpec.
func (in *KafkaConsumerGroupTopicBatchDeleteSpec) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaConsumerGroupTopicBatchDeleteStatus) DeepCopyInto(out *KafkaConsumerGroupTopicBatchDeleteStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaConsumerGroupTopicBatchDeleteStatus.
func (in *KafkaConsumerGroupTopicBatchDeleteStatus) DeepCopy() *KafkaConsumerGroupTopicBatchDeleteStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaConsumerGroupTopicBatchDeleteStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstance) DeepCopyInto(out *KafkaInstance) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstance.
func (in *KafkaInstance) DeepCopy() *KafkaInstance {
	if in == nil {
		return nil
	}
	out := new(KafkaInstance)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstance) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchAction) DeepCopyInto(out *KafkaInstanceBatchAction) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchAction.
func (in *KafkaInstanceBatchAction) DeepCopy() *KafkaInstanceBatchAction {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchAction)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceBatchAction) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionInitParameters) DeepCopyInto(out *KafkaInstanceBatchActionInitParameters) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.AllFailure != nil {
		in, out := &in.AllFailure, &out.AllFailure
		*out = new(string)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ForceDelete != nil {
		in, out := &in.ForceDelete, &out.ForceDelete
		*out = new(bool)
		**out = **in
	}
	if in.Instances != nil {
		in, out := &in.Instances, &out.Instances
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionInitParameters.
func (in *KafkaInstanceBatchActionInitParameters) DeepCopy() *KafkaInstanceBatchActionInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionList) DeepCopyInto(out *KafkaInstanceBatchActionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaInstanceBatchAction, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionList.
func (in *KafkaInstanceBatchActionList) DeepCopy() *KafkaInstanceBatchActionList {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceBatchActionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionObservation) DeepCopyInto(out *KafkaInstanceBatchActionObservation) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.AllFailure != nil {
		in, out := &in.AllFailure, &out.AllFailure
		*out = new(string)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ForceDelete != nil {
		in, out := &in.ForceDelete, &out.ForceDelete
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Instances != nil {
		in, out := &in.Instances, &out.Instances
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionObservation.
func (in *KafkaInstanceBatchActionObservation) DeepCopy() *KafkaInstanceBatchActionObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionParameters) DeepCopyInto(out *KafkaInstanceBatchActionParameters) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.AllFailure != nil {
		in, out := &in.AllFailure, &out.AllFailure
		*out = new(string)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ForceDelete != nil {
		in, out := &in.ForceDelete, &out.ForceDelete
		*out = new(bool)
		**out = **in
	}
	if in.Instances != nil {
		in, out := &in.Instances, &out.Instances
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionParameters.
func (in *KafkaInstanceBatchActionParameters) DeepCopy() *KafkaInstanceBatchActionParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionSpec) DeepCopyInto(out *KafkaInstanceBatchActionSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionSpec.
func (in *KafkaInstanceBatchActionSpec) DeepCopy() *KafkaInstanceBatchActionSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceBatchActionStatus) DeepCopyInto(out *KafkaInstanceBatchActionStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceBatchActionStatus.
func (in *KafkaInstanceBatchActionStatus) DeepCopy() *KafkaInstanceBatchActionStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceBatchActionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceInitParameters) DeepCopyInto(out *KafkaInstanceInitParameters) {
	*out = *in
	if in.AccessUser != nil {
		in, out := &in.AccessUser, &out.AccessUser
		*out = new(string)
		**out = **in
	}
	if in.ArchType != nil {
		in, out := &in.ArchType, &out.ArchType
		*out = new(string)
		**out = **in
	}
	if in.AutoRenew != nil {
		in, out := &in.AutoRenew, &out.AutoRenew
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZones != nil {
		in, out := &in.AvailabilityZones, &out.AvailabilityZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AvailableZones != nil {
		in, out := &in.AvailableZones, &out.AvailableZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.BrokerNum != nil {
		in, out := &in.BrokerNum, &out.BrokerNum
		*out = new(float64)
		**out = **in
	}
	if in.ChargingMode != nil {
		in, out := &in.ChargingMode, &out.ChargingMode
		*out = new(string)
		**out = **in
	}
	if in.CrossVPCAccesses != nil {
		in, out := &in.CrossVPCAccesses, &out.CrossVPCAccesses
		*out = make([]CrossVPCAccessesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Dumping != nil {
		in, out := &in.Dumping, &out.Dumping
		*out = new(bool)
		**out = **in
	}
	if in.EnableAutoTopic != nil {
		in, out := &in.EnableAutoTopic, &out.EnableAutoTopic
		*out = new(bool)
		**out = **in
	}
	if in.EnabledMechanisms != nil {
		in, out := &in.EnabledMechanisms, &out.EnabledMechanisms
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.EnterpriseProjectID != nil {
		in, out := &in.EnterpriseProjectID, &out.EnterpriseProjectID
		*out = new(string)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.IPv6Enable != nil {
		in, out := &in.IPv6Enable, &out.IPv6Enable
		*out = new(bool)
		**out = **in
	}
	if in.KMSEncryptedPasswordSecretRef != nil {
		in, out := &in.KMSEncryptedPasswordSecretRef, &out.KMSEncryptedPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.MaintainBegin != nil {
		in, out := &in.MaintainBegin, &out.MaintainBegin
		*out = new(string)
		**out = **in
	}
	if in.MaintainEnd != nil {
		in, out := &in.MaintainEnd, &out.MaintainEnd
		*out = new(string)
		**out = **in
	}
	if in.ManagerPasswordSecretRef != nil {
		in, out := &in.ManagerPasswordSecretRef, &out.ManagerPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ManagerUser != nil {
		in, out := &in.ManagerUser, &out.ManagerUser
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkID != nil {
		in, out := &in.NetworkID, &out.NetworkID
		*out = new(string)
		**out = **in
	}
	if in.NetworkIDRef != nil {
		in, out := &in.NetworkIDRef, &out.NetworkIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.NetworkIDSelector != nil {
		in, out := &in.NetworkIDSelector, &out.NetworkIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.NewTenantIps != nil {
		in, out := &in.NewTenantIps, &out.NewTenantIps
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = make([]ParametersInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Period != nil {
		in, out := &in.Period, &out.Period
		*out = new(float64)
		**out = **in
	}
	if in.PeriodUnit != nil {
		in, out := &in.PeriodUnit, &out.PeriodUnit
		*out = new(string)
		**out = **in
	}
	if in.PortProtocol != nil {
		in, out := &in.PortProtocol, &out.PortProtocol
		*out = make([]PortProtocolInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicIPIds != nil {
		in, out := &in.PublicIPIds, &out.PublicIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RetentionPolicy != nil {
		in, out := &in.RetentionPolicy, &out.RetentionPolicy
		*out = new(string)
		**out = **in
	}
	if in.SSLEnable != nil {
		in, out := &in.SSLEnable, &out.SSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.SecurityGroupID != nil {
		in, out := &in.SecurityGroupID, &out.SecurityGroupID
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupIDRef != nil {
		in, out := &in.SecurityGroupIDRef, &out.SecurityGroupIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityGroupIDSelector != nil {
		in, out := &in.SecurityGroupIDSelector, &out.SecurityGroupIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.StorageSpace != nil {
		in, out := &in.StorageSpace, &out.StorageSpace
		*out = new(float64)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.VPCClientPlain != nil {
		in, out := &in.VPCClientPlain, &out.VPCClientPlain
		*out = new(bool)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
	if in.VPCIDRef != nil {
		in, out := &in.VPCIDRef, &out.VPCIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.VPCIDSelector != nil {
		in, out := &in.VPCIDSelector, &out.VPCIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceInitParameters.
func (in *KafkaInstanceInitParameters) DeepCopy() *KafkaInstanceInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceList) DeepCopyInto(out *KafkaInstanceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaInstance, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceList.
func (in *KafkaInstanceList) DeepCopy() *KafkaInstanceList {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceObservation) DeepCopyInto(out *KafkaInstanceObservation) {
	*out = *in
	if in.AccessUser != nil {
		in, out := &in.AccessUser, &out.AccessUser
		*out = new(string)
		**out = **in
	}
	if in.ArchType != nil {
		in, out := &in.ArchType, &out.ArchType
		*out = new(string)
		**out = **in
	}
	if in.AutoRenew != nil {
		in, out := &in.AutoRenew, &out.AutoRenew
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZones != nil {
		in, out := &in.AvailabilityZones, &out.AvailabilityZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AvailableZones != nil {
		in, out := &in.AvailableZones, &out.AvailableZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.BrokerNum != nil {
		in, out := &in.BrokerNum, &out.BrokerNum
		*out = new(float64)
		**out = **in
	}
	if in.CertReplaced != nil {
		in, out := &in.CertReplaced, &out.CertReplaced
		*out = new(bool)
		**out = **in
	}
	if in.ChargingMode != nil {
		in, out := &in.ChargingMode, &out.ChargingMode
		*out = new(string)
		**out = **in
	}
	if in.ConnectAddress != nil {
		in, out := &in.ConnectAddress, &out.ConnectAddress
		*out = new(string)
		**out = **in
	}
	if in.ConnectorID != nil {
		in, out := &in.ConnectorID, &out.ConnectorID
		*out = new(string)
		**out = **in
	}
	if in.ConnectorNodeNum != nil {
		in, out := &in.ConnectorNodeNum, &out.ConnectorNodeNum
		*out = new(float64)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.CrossVPCAccesses != nil {
		in, out := &in.CrossVPCAccesses, &out.CrossVPCAccesses
		*out = make([]CrossVPCAccessesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Dumping != nil {
		in, out := &in.Dumping, &out.Dumping
		*out = new(bool)
		**out = **in
	}
	if in.EnableAutoTopic != nil {
		in, out := &in.EnableAutoTopic, &out.EnableAutoTopic
		*out = new(bool)
		**out = **in
	}
	if in.EnablePublicIP != nil {
		in, out := &in.EnablePublicIP, &out.EnablePublicIP
		*out = new(bool)
		**out = **in
	}
	if in.EnabledMechanisms != nil {
		in, out := &in.EnabledMechanisms, &out.EnabledMechanisms
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Engine != nil {
		in, out := &in.Engine, &out.Engine
		*out = new(string)
		**out = **in
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.EnterpriseProjectID != nil {
		in, out := &in.EnterpriseProjectID, &out.EnterpriseProjectID
		*out = new(string)
		**out = **in
	}
	if in.ExtendTimes != nil {
		in, out := &in.ExtendTimes, &out.ExtendTimes
		*out = new(float64)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IPv6ConnectAddresses != nil {
		in, out := &in.IPv6ConnectAddresses, &out.IPv6ConnectAddresses
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.IPv6Enable != nil {
		in, out := &in.IPv6Enable, &out.IPv6Enable
		*out = new(bool)
		**out = **in
	}
	if in.IsLogicalVolume != nil {
		in, out := &in.IsLogicalVolume, &out.IsLogicalVolume
		*out = new(bool)
		**out = **in
	}
	if in.MaintainBegin != nil {
		in, out := &in.MaintainBegin, &out.MaintainBegin
		*out = new(string)
		**out = **in
	}
	if in.MaintainEnd != nil {
		in, out := &in.MaintainEnd, &out.MaintainEnd
		*out = new(string)
		**out = **in
	}
	if in.ManagementConnectAddress != nil {
		in, out := &in.ManagementConnectAddress, &out.ManagementConnectAddress
		*out = new(string)
		**out = **in
	}
	if in.ManagerUser != nil {
		in, out := &in.ManagerUser, &out.ManagerUser
		*out = new(string)
		**out = **in
	}
	if in.ManegementConnectAddress != nil {
		in, out := &in.ManegementConnectAddress, &out.ManegementConnectAddress
		*out = new(string)
		**out = **in
	}
	if in.MessageQueryInstEnable != nil {
		in, out := &in.MessageQueryInstEnable, &out.MessageQueryInstEnable
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkID != nil {
		in, out := &in.NetworkID, &out.NetworkID
		*out = new(string)
		**out = **in
	}
	if in.NewTenantIps != nil {
		in, out := &in.NewTenantIps, &out.NewTenantIps
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.NodeNum != nil {
		in, out := &in.NodeNum, &out.NodeNum
		*out = new(float64)
		**out = **in
	}
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = make([]ParametersObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PartitionNum != nil {
		in, out := &in.PartitionNum, &out.PartitionNum
		*out = new(float64)
		**out = **in
	}
	if in.Period != nil {
		in, out := &in.Period, &out.Period
		*out = new(float64)
		**out = **in
	}
	if in.PeriodUnit != nil {
		in, out := &in.PeriodUnit, &out.PeriodUnit
		*out = new(string)
		**out = **in
	}
	if in.PodConnectAddress != nil {
		in, out := &in.PodConnectAddress, &out.PodConnectAddress
		*out = new(string)
		**out = **in
	}
	if in.Port != nil {
		in, out := &in.Port, &out.Port
		*out = new(float64)
		**out = **in
	}
	if in.PortProtocol != nil {
		in, out := &in.PortProtocol, &out.PortProtocol
		*out = make([]PortProtocolObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PortProtocols != nil {
		in, out := &in.PortProtocols, &out.PortProtocols
		*out = make([]PortProtocolsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicBandwidth != nil {
		in, out := &in.PublicBandwidth, &out.PublicBandwidth
		*out = new(float64)
		**out = **in
	}
	if in.PublicIPAddress != nil {
		in, out := &in.PublicIPAddress, &out.PublicIPAddress
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.PublicIPIds != nil {
		in, out := &in.PublicIPIds, &out.PublicIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.ResourceSpecCode != nil {
		in, out := &in.ResourceSpecCode, &out.ResourceSpecCode
		*out = new(string)
		**out = **in
	}
	if in.RetentionPolicy != nil {
		in, out := &in.RetentionPolicy, &out.RetentionPolicy
		*out = new(string)
		**out = **in
	}
	if in.SSLEnable != nil {
		in, out := &in.SSLEnable, &out.SSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.SSLTwoWayEnable != nil {
		in, out := &in.SSLTwoWayEnable, &out.SSLTwoWayEnable
		*out = new(bool)
		**out = **in
	}
	if in.SecurityGroupID != nil {
		in, out := &in.SecurityGroupID, &out.SecurityGroupID
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.StorageResourceID != nil {
		in, out := &in.StorageResourceID, &out.StorageResourceID
		*out = new(string)
		**out = **in
	}
	if in.StorageSpace != nil {
		in, out := &in.StorageSpace, &out.StorageSpace
		*out = new(float64)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
	if in.StorageType != nil {
		in, out := &in.StorageType, &out.StorageType
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
	if in.UsedStorageSpace != nil {
		in, out := &in.UsedStorageSpace, &out.UsedStorageSpace
		*out = new(float64)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
	if in.VPCClientPlain != nil {
		in, out := &in.VPCClientPlain, &out.VPCClientPlain
		*out = new(bool)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceObservation.
func (in *KafkaInstanceObservation) DeepCopy() *KafkaInstanceObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceParameters) DeepCopyInto(out *KafkaInstanceParameters) {
	*out = *in
	if in.AccessUser != nil {
		in, out := &in.AccessUser, &out.AccessUser
		*out = new(string)
		**out = **in
	}
	if in.ArchType != nil {
		in, out := &in.ArchType, &out.ArchType
		*out = new(string)
		**out = **in
	}
	if in.AutoRenew != nil {
		in, out := &in.AutoRenew, &out.AutoRenew
		*out = new(string)
		**out = **in
	}
	if in.AvailabilityZones != nil {
		in, out := &in.AvailabilityZones, &out.AvailabilityZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AvailableZones != nil {
		in, out := &in.AvailableZones, &out.AvailableZones
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.BrokerNum != nil {
		in, out := &in.BrokerNum, &out.BrokerNum
		*out = new(float64)
		**out = **in
	}
	if in.ChargingMode != nil {
		in, out := &in.ChargingMode, &out.ChargingMode
		*out = new(string)
		**out = **in
	}
	if in.CrossVPCAccesses != nil {
		in, out := &in.CrossVPCAccesses, &out.CrossVPCAccesses
		*out = make([]CrossVPCAccessesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.Dumping != nil {
		in, out := &in.Dumping, &out.Dumping
		*out = new(bool)
		**out = **in
	}
	if in.EnableAutoTopic != nil {
		in, out := &in.EnableAutoTopic, &out.EnableAutoTopic
		*out = new(bool)
		**out = **in
	}
	if in.EnabledMechanisms != nil {
		in, out := &in.EnabledMechanisms, &out.EnabledMechanisms
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.EngineVersion != nil {
		in, out := &in.EngineVersion, &out.EngineVersion
		*out = new(string)
		**out = **in
	}
	if in.EnterpriseProjectID != nil {
		in, out := &in.EnterpriseProjectID, &out.EnterpriseProjectID
		*out = new(string)
		**out = **in
	}
	if in.FlavorID != nil {
		in, out := &in.FlavorID, &out.FlavorID
		*out = new(string)
		**out = **in
	}
	if in.IPv6Enable != nil {
		in, out := &in.IPv6Enable, &out.IPv6Enable
		*out = new(bool)
		**out = **in
	}
	if in.KMSEncryptedPasswordSecretRef != nil {
		in, out := &in.KMSEncryptedPasswordSecretRef, &out.KMSEncryptedPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.MaintainBegin != nil {
		in, out := &in.MaintainBegin, &out.MaintainBegin
		*out = new(string)
		**out = **in
	}
	if in.MaintainEnd != nil {
		in, out := &in.MaintainEnd, &out.MaintainEnd
		*out = new(string)
		**out = **in
	}
	if in.ManagerPasswordSecretRef != nil {
		in, out := &in.ManagerPasswordSecretRef, &out.ManagerPasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ManagerUser != nil {
		in, out := &in.ManagerUser, &out.ManagerUser
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NetworkID != nil {
		in, out := &in.NetworkID, &out.NetworkID
		*out = new(string)
		**out = **in
	}
	if in.NetworkIDRef != nil {
		in, out := &in.NetworkIDRef, &out.NetworkIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.NetworkIDSelector != nil {
		in, out := &in.NetworkIDSelector, &out.NetworkIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.NewTenantIps != nil {
		in, out := &in.NewTenantIps, &out.NewTenantIps
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = make([]ParametersParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.Period != nil {
		in, out := &in.Period, &out.Period
		*out = new(float64)
		**out = **in
	}
	if in.PeriodUnit != nil {
		in, out := &in.PeriodUnit, &out.PeriodUnit
		*out = new(string)
		**out = **in
	}
	if in.PortProtocol != nil {
		in, out := &in.PortProtocol, &out.PortProtocol
		*out = make([]PortProtocolParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ProductID != nil {
		in, out := &in.ProductID, &out.ProductID
		*out = new(string)
		**out = **in
	}
	if in.PublicIPIds != nil {
		in, out := &in.PublicIPIds, &out.PublicIPIds
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.RetentionPolicy != nil {
		in, out := &in.RetentionPolicy, &out.RetentionPolicy
		*out = new(string)
		**out = **in
	}
	if in.SSLEnable != nil {
		in, out := &in.SSLEnable, &out.SSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.SecurityGroupID != nil {
		in, out := &in.SecurityGroupID, &out.SecurityGroupID
		*out = new(string)
		**out = **in
	}
	if in.SecurityGroupIDRef != nil {
		in, out := &in.SecurityGroupIDRef, &out.SecurityGroupIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityGroupIDSelector != nil {
		in, out := &in.SecurityGroupIDSelector, &out.SecurityGroupIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.StorageSpace != nil {
		in, out := &in.StorageSpace, &out.StorageSpace
		*out = new(float64)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.VPCClientPlain != nil {
		in, out := &in.VPCClientPlain, &out.VPCClientPlain
		*out = new(bool)
		**out = **in
	}
	if in.VPCID != nil {
		in, out := &in.VPCID, &out.VPCID
		*out = new(string)
		**out = **in
	}
	if in.VPCIDRef != nil {
		in, out := &in.VPCIDRef, &out.VPCIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.VPCIDSelector != nil {
		in, out := &in.VPCIDSelector, &out.VPCIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceParameters.
func (in *KafkaInstanceParameters) DeepCopy() *KafkaInstanceParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLog) DeepCopyInto(out *KafkaInstanceRebalanceLog) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLog.
func (in *KafkaInstanceRebalanceLog) DeepCopy() *KafkaInstanceRebalanceLog {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLog)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceRebalanceLog) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogInitParameters) DeepCopyInto(out *KafkaInstanceRebalanceLogInitParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogInitParameters.
func (in *KafkaInstanceRebalanceLogInitParameters) DeepCopy() *KafkaInstanceRebalanceLogInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogList) DeepCopyInto(out *KafkaInstanceRebalanceLogList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaInstanceRebalanceLog, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogList.
func (in *KafkaInstanceRebalanceLogList) DeepCopy() *KafkaInstanceRebalanceLogList {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceRebalanceLogList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogObservation) DeepCopyInto(out *KafkaInstanceRebalanceLogObservation) {
	*out = *in
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DashboardID != nil {
		in, out := &in.DashboardID, &out.DashboardID
		*out = new(string)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.LogFileName != nil {
		in, out := &in.LogFileName, &out.LogFileName
		*out = new(string)
		**out = **in
	}
	if in.LogGroupID != nil {
		in, out := &in.LogGroupID, &out.LogGroupID
		*out = new(string)
		**out = **in
	}
	if in.LogStreamID != nil {
		in, out := &in.LogStreamID, &out.LogStreamID
		*out = new(string)
		**out = **in
	}
	if in.LogType != nil {
		in, out := &in.LogType, &out.LogType
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.UpdatedAt != nil {
		in, out := &in.UpdatedAt, &out.UpdatedAt
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogObservation.
func (in *KafkaInstanceRebalanceLogObservation) DeepCopy() *KafkaInstanceRebalanceLogObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogParameters) DeepCopyInto(out *KafkaInstanceRebalanceLogParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogParameters.
func (in *KafkaInstanceRebalanceLogParameters) DeepCopy() *KafkaInstanceRebalanceLogParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogSpec) DeepCopyInto(out *KafkaInstanceRebalanceLogSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogSpec.
func (in *KafkaInstanceRebalanceLogSpec) DeepCopy() *KafkaInstanceRebalanceLogSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRebalanceLogStatus) DeepCopyInto(out *KafkaInstanceRebalanceLogStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRebalanceLogStatus.
func (in *KafkaInstanceRebalanceLogStatus) DeepCopy() *KafkaInstanceRebalanceLogStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRebalanceLogStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestart) DeepCopyInto(out *KafkaInstanceRestart) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestart.
func (in *KafkaInstanceRestart) DeepCopy() *KafkaInstanceRestart {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestart)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceRestart) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartInitParameters) DeepCopyInto(out *KafkaInstanceRestartInitParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartInitParameters.
func (in *KafkaInstanceRestartInitParameters) DeepCopy() *KafkaInstanceRestartInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartList) DeepCopyInto(out *KafkaInstanceRestartList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaInstanceRestart, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartList.
func (in *KafkaInstanceRestartList) DeepCopy() *KafkaInstanceRestartList {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaInstanceRestartList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartObservation) DeepCopyInto(out *KafkaInstanceRestartObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartObservation.
func (in *KafkaInstanceRestartObservation) DeepCopy() *KafkaInstanceRestartObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartParameters) DeepCopyInto(out *KafkaInstanceRestartParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartParameters.
func (in *KafkaInstanceRestartParameters) DeepCopy() *KafkaInstanceRestartParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartSpec) DeepCopyInto(out *KafkaInstanceRestartSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartSpec.
func (in *KafkaInstanceRestartSpec) DeepCopy() *KafkaInstanceRestartSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceRestartStatus) DeepCopyInto(out *KafkaInstanceRestartStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceRestartStatus.
func (in *KafkaInstanceRestartStatus) DeepCopy() *KafkaInstanceRestartStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceRestartStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceSpec) DeepCopyInto(out *KafkaInstanceSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceSpec.
func (in *KafkaInstanceSpec) DeepCopy() *KafkaInstanceSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaInstanceStatus) DeepCopyInto(out *KafkaInstanceStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaInstanceStatus.
func (in *KafkaInstanceStatus) DeepCopy() *KafkaInstanceStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaInstanceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTask) DeepCopyInto(out *KafkaMessageDiagnosisTask) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTask.
func (in *KafkaMessageDiagnosisTask) DeepCopy() *KafkaMessageDiagnosisTask {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTask)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageDiagnosisTask) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskInitParameters) DeepCopyInto(out *KafkaMessageDiagnosisTaskInitParameters) {
	*out = *in
	if in.GroupName != nil {
		in, out := &in.GroupName, &out.GroupName
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskInitParameters.
func (in *KafkaMessageDiagnosisTaskInitParameters) DeepCopy() *KafkaMessageDiagnosisTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskList) DeepCopyInto(out *KafkaMessageDiagnosisTaskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaMessageDiagnosisTask, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskList.
func (in *KafkaMessageDiagnosisTaskList) DeepCopy() *KafkaMessageDiagnosisTaskList {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageDiagnosisTaskList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskObservation) DeepCopyInto(out *KafkaMessageDiagnosisTaskObservation) {
	*out = *in
	if in.AccumulatedPartitions != nil {
		in, out := &in.AccumulatedPartitions, &out.AccumulatedPartitions
		*out = new(float64)
		**out = **in
	}
	if in.BeginTime != nil {
		in, out := &in.BeginTime, &out.BeginTime
		*out = new(string)
		**out = **in
	}
	if in.DiagnosisDimensionList != nil {
		in, out := &in.DiagnosisDimensionList, &out.DiagnosisDimensionList
		*out = make([]DiagnosisDimensionListObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.EndTime != nil {
		in, out := &in.EndTime, &out.EndTime
		*out = new(string)
		**out = **in
	}
	if in.GroupName != nil {
		in, out := &in.GroupName, &out.GroupName
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskObservation.
func (in *KafkaMessageDiagnosisTaskObservation) DeepCopy() *KafkaMessageDiagnosisTaskObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskParameters) DeepCopyInto(out *KafkaMessageDiagnosisTaskParameters) {
	*out = *in
	if in.GroupName != nil {
		in, out := &in.GroupName, &out.GroupName
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskParameters.
func (in *KafkaMessageDiagnosisTaskParameters) DeepCopy() *KafkaMessageDiagnosisTaskParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskSpec) DeepCopyInto(out *KafkaMessageDiagnosisTaskSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskSpec.
func (in *KafkaMessageDiagnosisTaskSpec) DeepCopy() *KafkaMessageDiagnosisTaskSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageDiagnosisTaskStatus) DeepCopyInto(out *KafkaMessageDiagnosisTaskStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageDiagnosisTaskStatus.
func (in *KafkaMessageDiagnosisTaskStatus) DeepCopy() *KafkaMessageDiagnosisTaskStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageDiagnosisTaskStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetReset) DeepCopyInto(out *KafkaMessageOffsetReset) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetReset.
func (in *KafkaMessageOffsetReset) DeepCopy() *KafkaMessageOffsetReset {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetReset)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageOffsetReset) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetInitParameters) DeepCopyInto(out *KafkaMessageOffsetResetInitParameters) {
	*out = *in
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.MessageOffset != nil {
		in, out := &in.MessageOffset, &out.MessageOffset
		*out = new(string)
		**out = **in
	}
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Timestamp != nil {
		in, out := &in.Timestamp, &out.Timestamp
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetInitParameters.
func (in *KafkaMessageOffsetResetInitParameters) DeepCopy() *KafkaMessageOffsetResetInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetList) DeepCopyInto(out *KafkaMessageOffsetResetList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaMessageOffsetReset, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetList.
func (in *KafkaMessageOffsetResetList) DeepCopy() *KafkaMessageOffsetResetList {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageOffsetResetList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetObservation) DeepCopyInto(out *KafkaMessageOffsetResetObservation) {
	*out = *in
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.MessageOffset != nil {
		in, out := &in.MessageOffset, &out.MessageOffset
		*out = new(string)
		**out = **in
	}
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Timestamp != nil {
		in, out := &in.Timestamp, &out.Timestamp
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetObservation.
func (in *KafkaMessageOffsetResetObservation) DeepCopy() *KafkaMessageOffsetResetObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetParameters) DeepCopyInto(out *KafkaMessageOffsetResetParameters) {
	*out = *in
	if in.Group != nil {
		in, out := &in.Group, &out.Group
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.MessageOffset != nil {
		in, out := &in.MessageOffset, &out.MessageOffset
		*out = new(string)
		**out = **in
	}
	if in.Partition != nil {
		in, out := &in.Partition, &out.Partition
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Timestamp != nil {
		in, out := &in.Timestamp, &out.Timestamp
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetParameters.
func (in *KafkaMessageOffsetResetParameters) DeepCopy() *KafkaMessageOffsetResetParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetSpec) DeepCopyInto(out *KafkaMessageOffsetResetSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetSpec.
func (in *KafkaMessageOffsetResetSpec) DeepCopy() *KafkaMessageOffsetResetSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageOffsetResetStatus) DeepCopyInto(out *KafkaMessageOffsetResetStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageOffsetResetStatus.
func (in *KafkaMessageOffsetResetStatus) DeepCopy() *KafkaMessageOffsetResetStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageOffsetResetStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduce) DeepCopyInto(out *KafkaMessageProduce) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduce.
func (in *KafkaMessageProduce) DeepCopy() *KafkaMessageProduce {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduce)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageProduce) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceInitParameters) DeepCopyInto(out *KafkaMessageProduceInitParameters) {
	*out = *in
	if in.Body != nil {
		in, out := &in.Body, &out.Body
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyList != nil {
		in, out := &in.PropertyList, &out.PropertyList
		*out = make([]PropertyListInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceInitParameters.
func (in *KafkaMessageProduceInitParameters) DeepCopy() *KafkaMessageProduceInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceList) DeepCopyInto(out *KafkaMessageProduceList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaMessageProduce, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceList.
func (in *KafkaMessageProduceList) DeepCopy() *KafkaMessageProduceList {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaMessageProduceList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceObservation) DeepCopyInto(out *KafkaMessageProduceObservation) {
	*out = *in
	if in.Body != nil {
		in, out := &in.Body, &out.Body
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.PropertyList != nil {
		in, out := &in.PropertyList, &out.PropertyList
		*out = make([]PropertyListObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceObservation.
func (in *KafkaMessageProduceObservation) DeepCopy() *KafkaMessageProduceObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceParameters) DeepCopyInto(out *KafkaMessageProduceParameters) {
	*out = *in
	if in.Body != nil {
		in, out := &in.Body, &out.Body
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.PropertyList != nil {
		in, out := &in.PropertyList, &out.PropertyList
		*out = make([]PropertyListParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceParameters.
func (in *KafkaMessageProduceParameters) DeepCopy() *KafkaMessageProduceParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceSpec) DeepCopyInto(out *KafkaMessageProduceSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceSpec.
func (in *KafkaMessageProduceSpec) DeepCopy() *KafkaMessageProduceSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaMessageProduceStatus) DeepCopyInto(out *KafkaMessageProduceStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaMessageProduceStatus.
func (in *KafkaMessageProduceStatus) DeepCopy() *KafkaMessageProduceStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaMessageProduceStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassign) DeepCopyInto(out *KafkaPartitionReassign) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassign.
func (in *KafkaPartitionReassign) DeepCopy() *KafkaPartitionReassign {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassign)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaPartitionReassign) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignInitParameters) DeepCopyInto(out *KafkaPartitionReassignInitParameters) {
	*out = *in
	if in.ExecuteAt != nil {
		in, out := &in.ExecuteAt, &out.ExecuteAt
		*out = new(float64)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.IsSchedule != nil {
		in, out := &in.IsSchedule, &out.IsSchedule
		*out = new(bool)
		**out = **in
	}
	if in.Reassignments != nil {
		in, out := &in.Reassignments, &out.Reassignments
		*out = make([]ReassignmentsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Throttle != nil {
		in, out := &in.Throttle, &out.Throttle
		*out = new(float64)
		**out = **in
	}
	if in.TimeEstimate != nil {
		in, out := &in.TimeEstimate, &out.TimeEstimate
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignInitParameters.
func (in *KafkaPartitionReassignInitParameters) DeepCopy() *KafkaPartitionReassignInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignList) DeepCopyInto(out *KafkaPartitionReassignList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaPartitionReassign, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignList.
func (in *KafkaPartitionReassignList) DeepCopy() *KafkaPartitionReassignList {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaPartitionReassignList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignObservation) DeepCopyInto(out *KafkaPartitionReassignObservation) {
	*out = *in
	if in.ExecuteAt != nil {
		in, out := &in.ExecuteAt, &out.ExecuteAt
		*out = new(float64)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.IsSchedule != nil {
		in, out := &in.IsSchedule, &out.IsSchedule
		*out = new(bool)
		**out = **in
	}
	if in.ReassignmentTime != nil {
		in, out := &in.ReassignmentTime, &out.ReassignmentTime
		*out = new(float64)
		**out = **in
	}
	if in.Reassignments != nil {
		in, out := &in.Reassignments, &out.Reassignments
		*out = make([]ReassignmentsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
	if in.Throttle != nil {
		in, out := &in.Throttle, &out.Throttle
		*out = new(float64)
		**out = **in
	}
	if in.TimeEstimate != nil {
		in, out := &in.TimeEstimate, &out.TimeEstimate
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignObservation.
func (in *KafkaPartitionReassignObservation) DeepCopy() *KafkaPartitionReassignObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignParameters) DeepCopyInto(out *KafkaPartitionReassignParameters) {
	*out = *in
	if in.ExecuteAt != nil {
		in, out := &in.ExecuteAt, &out.ExecuteAt
		*out = new(float64)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.IsSchedule != nil {
		in, out := &in.IsSchedule, &out.IsSchedule
		*out = new(bool)
		**out = **in
	}
	if in.Reassignments != nil {
		in, out := &in.Reassignments, &out.Reassignments
		*out = make([]ReassignmentsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Throttle != nil {
		in, out := &in.Throttle, &out.Throttle
		*out = new(float64)
		**out = **in
	}
	if in.TimeEstimate != nil {
		in, out := &in.TimeEstimate, &out.TimeEstimate
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignParameters.
func (in *KafkaPartitionReassignParameters) DeepCopy() *KafkaPartitionReassignParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignSpec) DeepCopyInto(out *KafkaPartitionReassignSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignSpec.
func (in *KafkaPartitionReassignSpec) DeepCopy() *KafkaPartitionReassignSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPartitionReassignStatus) DeepCopyInto(out *KafkaPartitionReassignStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPartitionReassignStatus.
func (in *KafkaPartitionReassignStatus) DeepCopy() *KafkaPartitionReassignStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaPartitionReassignStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissions) DeepCopyInto(out *KafkaPermissions) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissions.
func (in *KafkaPermissions) DeepCopy() *KafkaPermissions {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaPermissions) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsInitParameters) DeepCopyInto(out *KafkaPermissionsInitParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Policies != nil {
		in, out := &in.Policies, &out.Policies
		*out = make([]PoliciesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsInitParameters.
func (in *KafkaPermissionsInitParameters) DeepCopy() *KafkaPermissionsInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsList) DeepCopyInto(out *KafkaPermissionsList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaPermissions, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsList.
func (in *KafkaPermissionsList) DeepCopy() *KafkaPermissionsList {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaPermissionsList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsObservation) DeepCopyInto(out *KafkaPermissionsObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Policies != nil {
		in, out := &in.Policies, &out.Policies
		*out = make([]PoliciesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsObservation.
func (in *KafkaPermissionsObservation) DeepCopy() *KafkaPermissionsObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsParameters) DeepCopyInto(out *KafkaPermissionsParameters) {
	*out = *in
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Policies != nil {
		in, out := &in.Policies, &out.Policies
		*out = make([]PoliciesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TopicName != nil {
		in, out := &in.TopicName, &out.TopicName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsParameters.
func (in *KafkaPermissionsParameters) DeepCopy() *KafkaPermissionsParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsSpec) DeepCopyInto(out *KafkaPermissionsSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsSpec.
func (in *KafkaPermissionsSpec) DeepCopy() *KafkaPermissionsSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaPermissionsStatus) DeepCopyInto(out *KafkaPermissionsStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaPermissionsStatus.
func (in *KafkaPermissionsStatus) DeepCopy() *KafkaPermissionsStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaPermissionsStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnect) DeepCopyInto(out *KafkaSmartConnect) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnect.
func (in *KafkaSmartConnect) DeepCopy() *KafkaSmartConnect {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnect)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnect) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectInitParameters) DeepCopyInto(out *KafkaSmartConnectInitParameters) {
	*out = *in
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectInitParameters.
func (in *KafkaSmartConnectInitParameters) DeepCopy() *KafkaSmartConnectInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectList) DeepCopyInto(out *KafkaSmartConnectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSmartConnect, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectList.
func (in *KafkaSmartConnectList) DeepCopy() *KafkaSmartConnectList {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectObservation) DeepCopyInto(out *KafkaSmartConnectObservation) {
	*out = *in
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectObservation.
func (in *KafkaSmartConnectObservation) DeepCopy() *KafkaSmartConnectObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectParameters) DeepCopyInto(out *KafkaSmartConnectParameters) {
	*out = *in
	if in.Bandwidth != nil {
		in, out := &in.Bandwidth, &out.Bandwidth
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.NodeCount != nil {
		in, out := &in.NodeCount, &out.NodeCount
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.StorageSpecCode != nil {
		in, out := &in.StorageSpecCode, &out.StorageSpecCode
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectParameters.
func (in *KafkaSmartConnectParameters) DeepCopy() *KafkaSmartConnectParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectSpec) DeepCopyInto(out *KafkaSmartConnectSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectSpec.
func (in *KafkaSmartConnectSpec) DeepCopy() *KafkaSmartConnectSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectStatus) DeepCopyInto(out *KafkaSmartConnectStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectStatus.
func (in *KafkaSmartConnectStatus) DeepCopy() *KafkaSmartConnectStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTask) DeepCopyInto(out *KafkaSmartConnectTask) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTask.
func (in *KafkaSmartConnectTask) DeepCopy() *KafkaSmartConnectTask {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTask)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectTask) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskAction) DeepCopyInto(out *KafkaSmartConnectTaskAction) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskAction.
func (in *KafkaSmartConnectTaskAction) DeepCopy() *KafkaSmartConnectTaskAction {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskAction)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectTaskAction) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionInitParameters) DeepCopyInto(out *KafkaSmartConnectTaskActionInitParameters) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
	if in.TaskIDRef != nil {
		in, out := &in.TaskIDRef, &out.TaskIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.TaskIDSelector != nil {
		in, out := &in.TaskIDSelector, &out.TaskIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionInitParameters.
func (in *KafkaSmartConnectTaskActionInitParameters) DeepCopy() *KafkaSmartConnectTaskActionInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionList) DeepCopyInto(out *KafkaSmartConnectTaskActionList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSmartConnectTaskAction, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionList.
func (in *KafkaSmartConnectTaskActionList) DeepCopy() *KafkaSmartConnectTaskActionList {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectTaskActionList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionObservation) DeepCopyInto(out *KafkaSmartConnectTaskActionObservation) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionObservation.
func (in *KafkaSmartConnectTaskActionObservation) DeepCopy() *KafkaSmartConnectTaskActionObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionParameters) DeepCopyInto(out *KafkaSmartConnectTaskActionParameters) {
	*out = *in
	if in.Action != nil {
		in, out := &in.Action, &out.Action
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.TaskID != nil {
		in, out := &in.TaskID, &out.TaskID
		*out = new(string)
		**out = **in
	}
	if in.TaskIDRef != nil {
		in, out := &in.TaskIDRef, &out.TaskIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.TaskIDSelector != nil {
		in, out := &in.TaskIDSelector, &out.TaskIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionParameters.
func (in *KafkaSmartConnectTaskActionParameters) DeepCopy() *KafkaSmartConnectTaskActionParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionSpec) DeepCopyInto(out *KafkaSmartConnectTaskActionSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionSpec.
func (in *KafkaSmartConnectTaskActionSpec) DeepCopy() *KafkaSmartConnectTaskActionSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskActionStatus) DeepCopyInto(out *KafkaSmartConnectTaskActionStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskActionStatus.
func (in *KafkaSmartConnectTaskActionStatus) DeepCopy() *KafkaSmartConnectTaskActionStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskActionStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskInitParameters) DeepCopyInto(out *KafkaSmartConnectTaskInitParameters) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.ConnectorID != nil {
		in, out := &in.ConnectorID, &out.ConnectorID
		*out = new(string)
		**out = **in
	}
	if in.ConnectorIDRef != nil {
		in, out := &in.ConnectorIDRef, &out.ConnectorIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ConnectorIDSelector != nil {
		in, out := &in.ConnectorIDSelector, &out.ConnectorIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	out.SecretKeySecretRef = in.SecretKeySecretRef
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = new(string)
		**out = **in
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskInitParameters.
func (in *KafkaSmartConnectTaskInitParameters) DeepCopy() *KafkaSmartConnectTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskList) DeepCopyInto(out *KafkaSmartConnectTaskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSmartConnectTask, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskList.
func (in *KafkaSmartConnectTaskList) DeepCopy() *KafkaSmartConnectTaskList {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectTaskList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskObservation) DeepCopyInto(out *KafkaSmartConnectTaskObservation) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.ConnectorID != nil {
		in, out := &in.ConnectorID, &out.ConnectorID
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = new(string)
		**out = **in
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskObservation.
func (in *KafkaSmartConnectTaskObservation) DeepCopy() *KafkaSmartConnectTaskObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskParameters) DeepCopyInto(out *KafkaSmartConnectTaskParameters) {
	*out = *in
	if in.AccessKey != nil {
		in, out := &in.AccessKey, &out.AccessKey
		*out = new(string)
		**out = **in
	}
	if in.ConnectorID != nil {
		in, out := &in.ConnectorID, &out.ConnectorID
		*out = new(string)
		**out = **in
	}
	if in.ConnectorIDRef != nil {
		in, out := &in.ConnectorIDRef, &out.ConnectorIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.ConnectorIDSelector != nil {
		in, out := &in.ConnectorIDSelector, &out.ConnectorIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.DeliverTimeInterval != nil {
		in, out := &in.DeliverTimeInterval, &out.DeliverTimeInterval
		*out = new(float64)
		**out = **in
	}
	if in.DestinationFileType != nil {
		in, out := &in.DestinationFileType, &out.DestinationFileType
		*out = new(string)
		**out = **in
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.ObsBucketName != nil {
		in, out := &in.ObsBucketName, &out.ObsBucketName
		*out = new(string)
		**out = **in
	}
	if in.ObsPath != nil {
		in, out := &in.ObsPath, &out.ObsPath
		*out = new(string)
		**out = **in
	}
	if in.PartitionFormat != nil {
		in, out := &in.PartitionFormat, &out.PartitionFormat
		*out = new(string)
		**out = **in
	}
	if in.RecordDelimiter != nil {
		in, out := &in.RecordDelimiter, &out.RecordDelimiter
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	out.SecretKeySecretRef = in.SecretKeySecretRef
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = new(string)
		**out = **in
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskParameters.
func (in *KafkaSmartConnectTaskParameters) DeepCopy() *KafkaSmartConnectTaskParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskSpec) DeepCopyInto(out *KafkaSmartConnectTaskSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskSpec.
func (in *KafkaSmartConnectTaskSpec) DeepCopy() *KafkaSmartConnectTaskSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectTaskStatus) DeepCopyInto(out *KafkaSmartConnectTaskStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectTaskStatus.
func (in *KafkaSmartConnectTaskStatus) DeepCopy() *KafkaSmartConnectTaskStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectTaskStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidate) DeepCopyInto(out *KafkaSmartConnectorValidate) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidate.
func (in *KafkaSmartConnectorValidate) DeepCopy() *KafkaSmartConnectorValidate {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectorValidate) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateInitParameters) DeepCopyInto(out *KafkaSmartConnectorValidateInitParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Task != nil {
		in, out := &in.Task, &out.Task
		*out = make([]TaskInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateInitParameters.
func (in *KafkaSmartConnectorValidateInitParameters) DeepCopy() *KafkaSmartConnectorValidateInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateList) DeepCopyInto(out *KafkaSmartConnectorValidateList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaSmartConnectorValidate, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateList.
func (in *KafkaSmartConnectorValidateList) DeepCopy() *KafkaSmartConnectorValidateList {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaSmartConnectorValidateList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateObservation) DeepCopyInto(out *KafkaSmartConnectorValidateObservation) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Task != nil {
		in, out := &in.Task, &out.Task
		*out = make([]TaskObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateObservation.
func (in *KafkaSmartConnectorValidateObservation) DeepCopy() *KafkaSmartConnectorValidateObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateParameters) DeepCopyInto(out *KafkaSmartConnectorValidateParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Task != nil {
		in, out := &in.Task, &out.Task
		*out = make([]TaskParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateParameters.
func (in *KafkaSmartConnectorValidateParameters) DeepCopy() *KafkaSmartConnectorValidateParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateSpec) DeepCopyInto(out *KafkaSmartConnectorValidateSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateSpec.
func (in *KafkaSmartConnectorValidateSpec) DeepCopy() *KafkaSmartConnectorValidateSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaSmartConnectorValidateStatus) DeepCopyInto(out *KafkaSmartConnectorValidateStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaSmartConnectorValidateStatus.
func (in *KafkaSmartConnectorValidateStatus) DeepCopy() *KafkaSmartConnectorValidateStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaSmartConnectorValidateStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopic) DeepCopyInto(out *KafkaTopic) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopic.
func (in *KafkaTopic) DeepCopy() *KafkaTopic {
	if in == nil {
		return nil
	}
	out := new(KafkaTopic)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopic) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicInitParameters) DeepCopyInto(out *KafkaTopicInitParameters) {
	*out = *in
	if in.AgingTime != nil {
		in, out := &in.AgingTime, &out.AgingTime
		*out = new(float64)
		**out = **in
	}
	if in.Configs != nil {
		in, out := &in.Configs, &out.Configs
		*out = make([]ConfigsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NewPartitionBrokers != nil {
		in, out := &in.NewPartitionBrokers, &out.NewPartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(float64)
		**out = **in
	}
	if in.SyncFlushing != nil {
		in, out := &in.SyncFlushing, &out.SyncFlushing
		*out = new(bool)
		**out = **in
	}
	if in.SyncReplication != nil {
		in, out := &in.SyncReplication, &out.SyncReplication
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicInitParameters.
func (in *KafkaTopicInitParameters) DeepCopy() *KafkaTopicInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicList) DeepCopyInto(out *KafkaTopicList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaTopic, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicList.
func (in *KafkaTopicList) DeepCopy() *KafkaTopicList {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicObservation) DeepCopyInto(out *KafkaTopicObservation) {
	*out = *in
	if in.AgingTime != nil {
		in, out := &in.AgingTime, &out.AgingTime
		*out = new(float64)
		**out = **in
	}
	if in.Configs != nil {
		in, out := &in.Configs, &out.Configs
		*out = make([]ConfigsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NewPartitionBrokers != nil {
		in, out := &in.NewPartitionBrokers, &out.NewPartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(float64)
		**out = **in
	}
	if in.PoliciesOnly != nil {
		in, out := &in.PoliciesOnly, &out.PoliciesOnly
		*out = new(bool)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(float64)
		**out = **in
	}
	if in.SyncFlushing != nil {
		in, out := &in.SyncFlushing, &out.SyncFlushing
		*out = new(bool)
		**out = **in
	}
	if in.SyncReplication != nil {
		in, out := &in.SyncReplication, &out.SyncReplication
		*out = new(bool)
		**out = **in
	}
	if in.Type != nil {
		in, out := &in.Type, &out.Type
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicObservation.
func (in *KafkaTopicObservation) DeepCopy() *KafkaTopicObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicParameters) DeepCopyInto(out *KafkaTopicParameters) {
	*out = *in
	if in.AgingTime != nil {
		in, out := &in.AgingTime, &out.AgingTime
		*out = new(float64)
		**out = **in
	}
	if in.Configs != nil {
		in, out := &in.Configs, &out.Configs
		*out = make([]ConfigsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NewPartitionBrokers != nil {
		in, out := &in.NewPartitionBrokers, &out.NewPartitionBrokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.Partitions != nil {
		in, out := &in.Partitions, &out.Partitions
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Replicas != nil {
		in, out := &in.Replicas, &out.Replicas
		*out = new(float64)
		**out = **in
	}
	if in.SyncFlushing != nil {
		in, out := &in.SyncFlushing, &out.SyncFlushing
		*out = new(bool)
		**out = **in
	}
	if in.SyncReplication != nil {
		in, out := &in.SyncReplication, &out.SyncReplication
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicParameters.
func (in *KafkaTopicParameters) DeepCopy() *KafkaTopicParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuota) DeepCopyInto(out *KafkaTopicQuota) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuota.
func (in *KafkaTopicQuota) DeepCopy() *KafkaTopicQuota {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuota)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicQuota) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaInitParameters) DeepCopyInto(out *KafkaTopicQuotaInitParameters) {
	*out = *in
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaInitParameters.
func (in *KafkaTopicQuotaInitParameters) DeepCopy() *KafkaTopicQuotaInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaList) DeepCopyInto(out *KafkaTopicQuotaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaTopicQuota, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaList.
func (in *KafkaTopicQuotaList) DeepCopy() *KafkaTopicQuotaList {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaTopicQuotaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaObservation) DeepCopyInto(out *KafkaTopicQuotaObservation) {
	*out = *in
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaObservation.
func (in *KafkaTopicQuotaObservation) DeepCopy() *KafkaTopicQuotaObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaParameters) DeepCopyInto(out *KafkaTopicQuotaParameters) {
	*out = *in
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaParameters.
func (in *KafkaTopicQuotaParameters) DeepCopy() *KafkaTopicQuotaParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaSpec) DeepCopyInto(out *KafkaTopicQuotaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaSpec.
func (in *KafkaTopicQuotaSpec) DeepCopy() *KafkaTopicQuotaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicQuotaStatus) DeepCopyInto(out *KafkaTopicQuotaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicQuotaStatus.
func (in *KafkaTopicQuotaStatus) DeepCopy() *KafkaTopicQuotaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicQuotaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicSpec) DeepCopyInto(out *KafkaTopicSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicSpec.
func (in *KafkaTopicSpec) DeepCopy() *KafkaTopicSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaTopicStatus) DeepCopyInto(out *KafkaTopicStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaTopicStatus.
func (in *KafkaTopicStatus) DeepCopy() *KafkaTopicStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaTopicStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUser) DeepCopyInto(out *KafkaUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUser.
func (in *KafkaUser) DeepCopy() *KafkaUser {
	if in == nil {
		return nil
	}
	out := new(KafkaUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuota) DeepCopyInto(out *KafkaUserClientQuota) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuota.
func (in *KafkaUserClientQuota) DeepCopy() *KafkaUserClientQuota {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuota)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUserClientQuota) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaInitParameters) DeepCopyInto(out *KafkaUserClientQuotaInitParameters) {
	*out = *in
	if in.Client != nil {
		in, out := &in.Client, &out.Client
		*out = new(string)
		**out = **in
	}
	if in.ClientDefault != nil {
		in, out := &in.ClientDefault, &out.ClientDefault
		*out = new(bool)
		**out = **in
	}
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = new(string)
		**out = **in
	}
	if in.UserDefault != nil {
		in, out := &in.UserDefault, &out.UserDefault
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaInitParameters.
func (in *KafkaUserClientQuotaInitParameters) DeepCopy() *KafkaUserClientQuotaInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaList) DeepCopyInto(out *KafkaUserClientQuotaList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaUserClientQuota, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaList.
func (in *KafkaUserClientQuotaList) DeepCopy() *KafkaUserClientQuotaList {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUserClientQuotaList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaObservation) DeepCopyInto(out *KafkaUserClientQuotaObservation) {
	*out = *in
	if in.Client != nil {
		in, out := &in.Client, &out.Client
		*out = new(string)
		**out = **in
	}
	if in.ClientDefault != nil {
		in, out := &in.ClientDefault, &out.ClientDefault
		*out = new(bool)
		**out = **in
	}
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = new(string)
		**out = **in
	}
	if in.UserDefault != nil {
		in, out := &in.UserDefault, &out.UserDefault
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaObservation.
func (in *KafkaUserClientQuotaObservation) DeepCopy() *KafkaUserClientQuotaObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaParameters) DeepCopyInto(out *KafkaUserClientQuotaParameters) {
	*out = *in
	if in.Client != nil {
		in, out := &in.Client, &out.Client
		*out = new(string)
		**out = **in
	}
	if in.ClientDefault != nil {
		in, out := &in.ClientDefault, &out.ClientDefault
		*out = new(bool)
		**out = **in
	}
	if in.ConsumerByteRate != nil {
		in, out := &in.ConsumerByteRate, &out.ConsumerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.ProducerByteRate != nil {
		in, out := &in.ProducerByteRate, &out.ProducerByteRate
		*out = new(float64)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.User != nil {
		in, out := &in.User, &out.User
		*out = new(string)
		**out = **in
	}
	if in.UserDefault != nil {
		in, out := &in.UserDefault, &out.UserDefault
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaParameters.
func (in *KafkaUserClientQuotaParameters) DeepCopy() *KafkaUserClientQuotaParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaSpec) DeepCopyInto(out *KafkaUserClientQuotaSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaSpec.
func (in *KafkaUserClientQuotaSpec) DeepCopy() *KafkaUserClientQuotaSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserClientQuotaStatus) DeepCopyInto(out *KafkaUserClientQuotaStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserClientQuotaStatus.
func (in *KafkaUserClientQuotaStatus) DeepCopy() *KafkaUserClientQuotaStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaUserClientQuotaStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserInitParameters) DeepCopyInto(out *KafkaUserInitParameters) {
	*out = *in
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserInitParameters.
func (in *KafkaUserInitParameters) DeepCopy() *KafkaUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserList) DeepCopyInto(out *KafkaUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserList.
func (in *KafkaUserList) DeepCopy() *KafkaUserList {
	if in == nil {
		return nil
	}
	out := new(KafkaUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserObservation) DeepCopyInto(out *KafkaUserObservation) {
	*out = *in
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DefaultApp != nil {
		in, out := &in.DefaultApp, &out.DefaultApp
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.Role != nil {
		in, out := &in.Role, &out.Role
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserObservation.
func (in *KafkaUserObservation) DeepCopy() *KafkaUserObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserParameters) DeepCopyInto(out *KafkaUserParameters) {
	*out = *in
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	out.PasswordSecretRef = in.PasswordSecretRef
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserParameters.
func (in *KafkaUserParameters) DeepCopy() *KafkaUserParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordReset) DeepCopyInto(out *KafkaUserPasswordReset) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordReset.
func (in *KafkaUserPasswordReset) DeepCopy() *KafkaUserPasswordReset {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordReset)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUserPasswordReset) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetInitParameters) DeepCopyInto(out *KafkaUserPasswordResetInitParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	out.NewPasswordSecretRef = in.NewPasswordSecretRef
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetInitParameters.
func (in *KafkaUserPasswordResetInitParameters) DeepCopy() *KafkaUserPasswordResetInitParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetList) DeepCopyInto(out *KafkaUserPasswordResetList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]KafkaUserPasswordReset, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetList.
func (in *KafkaUserPasswordResetList) DeepCopy() *KafkaUserPasswordResetList {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KafkaUserPasswordResetList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetObservation) DeepCopyInto(out *KafkaUserPasswordResetObservation) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetObservation.
func (in *KafkaUserPasswordResetObservation) DeepCopy() *KafkaUserPasswordResetObservation {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetParameters) DeepCopyInto(out *KafkaUserPasswordResetParameters) {
	*out = *in
	if in.EnableForceNew != nil {
		in, out := &in.EnableForceNew, &out.EnableForceNew
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	out.NewPasswordSecretRef = in.NewPasswordSecretRef
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetParameters.
func (in *KafkaUserPasswordResetParameters) DeepCopy() *KafkaUserPasswordResetParameters {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetSpec) DeepCopyInto(out *KafkaUserPasswordResetSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetSpec.
func (in *KafkaUserPasswordResetSpec) DeepCopy() *KafkaUserPasswordResetSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserPasswordResetStatus) DeepCopyInto(out *KafkaUserPasswordResetStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserPasswordResetStatus.
func (in *KafkaUserPasswordResetStatus) DeepCopy() *KafkaUserPasswordResetStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaUserPasswordResetStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserSpec) DeepCopyInto(out *KafkaUserSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserSpec.
func (in *KafkaUserSpec) DeepCopy() *KafkaUserSpec {
	if in == nil {
		return nil
	}
	out := new(KafkaUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KafkaUserStatus) DeepCopyInto(out *KafkaUserStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KafkaUserStatus.
func (in *KafkaUserStatus) DeepCopy() *KafkaUserStatus {
	if in == nil {
		return nil
	}
	out := new(KafkaUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTask) DeepCopyInto(out *Kafkav2SmartConnectTask) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTask.
func (in *Kafkav2SmartConnectTask) DeepCopy() *Kafkav2SmartConnectTask {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTask)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafkav2SmartConnectTask) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskInitParameters) DeepCopyInto(out *Kafkav2SmartConnectTaskInitParameters) {
	*out = *in
	if in.DestinationTask != nil {
		in, out := &in.DestinationTask, &out.DestinationTask
		*out = make([]DestinationTaskInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SourceTask != nil {
		in, out := &in.SourceTask, &out.SourceTask
		*out = make([]SourceTaskInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.StartLater != nil {
		in, out := &in.StartLater, &out.StartLater
		*out = new(bool)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskInitParameters.
func (in *Kafkav2SmartConnectTaskInitParameters) DeepCopy() *Kafkav2SmartConnectTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskList) DeepCopyInto(out *Kafkav2SmartConnectTaskList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Kafkav2SmartConnectTask, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskList.
func (in *Kafkav2SmartConnectTaskList) DeepCopy() *Kafkav2SmartConnectTaskList {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Kafkav2SmartConnectTaskList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskObservation) DeepCopyInto(out *Kafkav2SmartConnectTaskObservation) {
	*out = *in
	if in.CreatedAt != nil {
		in, out := &in.CreatedAt, &out.CreatedAt
		*out = new(string)
		**out = **in
	}
	if in.DestinationTask != nil {
		in, out := &in.DestinationTask, &out.DestinationTask
		*out = make([]DestinationTaskObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SourceTask != nil {
		in, out := &in.SourceTask, &out.SourceTask
		*out = make([]SourceTaskObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.StartLater != nil {
		in, out := &in.StartLater, &out.StartLater
		*out = new(bool)
		**out = **in
	}
	if in.Status != nil {
		in, out := &in.Status, &out.Status
		*out = new(string)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskObservation.
func (in *Kafkav2SmartConnectTaskObservation) DeepCopy() *Kafkav2SmartConnectTaskObservation {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskParameters) DeepCopyInto(out *Kafkav2SmartConnectTaskParameters) {
	*out = *in
	if in.DestinationTask != nil {
		in, out := &in.DestinationTask, &out.DestinationTask
		*out = make([]DestinationTaskParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.DestinationType != nil {
		in, out := &in.DestinationType, &out.DestinationType
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.InstanceIDRef != nil {
		in, out := &in.InstanceIDRef, &out.InstanceIDRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.InstanceIDSelector != nil {
		in, out := &in.InstanceIDSelector, &out.InstanceIDSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.Region != nil {
		in, out := &in.Region, &out.Region
		*out = new(string)
		**out = **in
	}
	if in.SourceTask != nil {
		in, out := &in.SourceTask, &out.SourceTask
		*out = make([]SourceTaskParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.SourceType != nil {
		in, out := &in.SourceType, &out.SourceType
		*out = new(string)
		**out = **in
	}
	if in.StartLater != nil {
		in, out := &in.StartLater, &out.StartLater
		*out = new(bool)
		**out = **in
	}
	if in.TaskName != nil {
		in, out := &in.TaskName, &out.TaskName
		*out = new(string)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TopicsRegex != nil {
		in, out := &in.TopicsRegex, &out.TopicsRegex
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskParameters.
func (in *Kafkav2SmartConnectTaskParameters) DeepCopy() *Kafkav2SmartConnectTaskParameters {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskSpec) DeepCopyInto(out *Kafkav2SmartConnectTaskSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskSpec.
func (in *Kafkav2SmartConnectTaskSpec) DeepCopy() *Kafkav2SmartConnectTaskSpec {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Kafkav2SmartConnectTaskStatus) DeepCopyInto(out *Kafkav2SmartConnectTaskStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Kafkav2SmartConnectTaskStatus.
func (in *Kafkav2SmartConnectTaskStatus) DeepCopy() *Kafkav2SmartConnectTaskStatus {
	if in == nil {
		return nil
	}
	out := new(Kafkav2SmartConnectTaskStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ParametersInitParameters) DeepCopyInto(out *ParametersInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ParametersInitParameters.
func (in *ParametersInitParameters) DeepCopy() *ParametersInitParameters {
	if in == nil {
		return nil
	}
	out := new(ParametersInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ParametersObservation) DeepCopyInto(out *ParametersObservation) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ParametersObservation.
func (in *ParametersObservation) DeepCopy() *ParametersObservation {
	if in == nil {
		return nil
	}
	out := new(ParametersObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ParametersParameters) DeepCopyInto(out *ParametersParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ParametersParameters.
func (in *ParametersParameters) DeepCopy() *ParametersParameters {
	if in == nil {
		return nil
	}
	out := new(ParametersParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PoliciesInitParameters) DeepCopyInto(out *PoliciesInitParameters) {
	*out = *in
	if in.AccessPolicy != nil {
		in, out := &in.AccessPolicy, &out.AccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PoliciesInitParameters.
func (in *PoliciesInitParameters) DeepCopy() *PoliciesInitParameters {
	if in == nil {
		return nil
	}
	out := new(PoliciesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PoliciesObservation) DeepCopyInto(out *PoliciesObservation) {
	*out = *in
	if in.AccessPolicy != nil {
		in, out := &in.AccessPolicy, &out.AccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PoliciesObservation.
func (in *PoliciesObservation) DeepCopy() *PoliciesObservation {
	if in == nil {
		return nil
	}
	out := new(PoliciesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PoliciesParameters) DeepCopyInto(out *PoliciesParameters) {
	*out = *in
	if in.AccessPolicy != nil {
		in, out := &in.AccessPolicy, &out.AccessPolicy
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PoliciesParameters.
func (in *PoliciesParameters) DeepCopy() *PoliciesParameters {
	if in == nil {
		return nil
	}
	out := new(PoliciesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolInitParameters) DeepCopyInto(out *PortProtocolInitParameters) {
	*out = *in
	if in.PrivatePlainEnable != nil {
		in, out := &in.PrivatePlainEnable, &out.PrivatePlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslPlaintextEnable != nil {
		in, out := &in.PrivateSaslPlaintextEnable, &out.PrivateSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslSSLEnable != nil {
		in, out := &in.PrivateSaslSSLEnable, &out.PrivateSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicPlainEnable != nil {
		in, out := &in.PublicPlainEnable, &out.PublicPlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslPlaintextEnable != nil {
		in, out := &in.PublicSaslPlaintextEnable, &out.PublicSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslSSLEnable != nil {
		in, out := &in.PublicSaslSSLEnable, &out.PublicSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolInitParameters.
func (in *PortProtocolInitParameters) DeepCopy() *PortProtocolInitParameters {
	if in == nil {
		return nil
	}
	out := new(PortProtocolInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolObservation) DeepCopyInto(out *PortProtocolObservation) {
	*out = *in
	if in.PrivatePlainAddress != nil {
		in, out := &in.PrivatePlainAddress, &out.PrivatePlainAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivatePlainDomainName != nil {
		in, out := &in.PrivatePlainDomainName, &out.PrivatePlainDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivatePlainEnable != nil {
		in, out := &in.PrivatePlainEnable, &out.PrivatePlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslPlaintextAddress != nil {
		in, out := &in.PrivateSaslPlaintextAddress, &out.PrivateSaslPlaintextAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslPlaintextDomainName != nil {
		in, out := &in.PrivateSaslPlaintextDomainName, &out.PrivateSaslPlaintextDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslPlaintextEnable != nil {
		in, out := &in.PrivateSaslPlaintextEnable, &out.PrivateSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslSSLAddress != nil {
		in, out := &in.PrivateSaslSSLAddress, &out.PrivateSaslSSLAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslSSLDomainName != nil {
		in, out := &in.PrivateSaslSSLDomainName, &out.PrivateSaslSSLDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslSSLEnable != nil {
		in, out := &in.PrivateSaslSSLEnable, &out.PrivateSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicPlainAddress != nil {
		in, out := &in.PublicPlainAddress, &out.PublicPlainAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicPlainDomainName != nil {
		in, out := &in.PublicPlainDomainName, &out.PublicPlainDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicPlainEnable != nil {
		in, out := &in.PublicPlainEnable, &out.PublicPlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslPlaintextAddress != nil {
		in, out := &in.PublicSaslPlaintextAddress, &out.PublicSaslPlaintextAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslPlaintextDomainName != nil {
		in, out := &in.PublicSaslPlaintextDomainName, &out.PublicSaslPlaintextDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslPlaintextEnable != nil {
		in, out := &in.PublicSaslPlaintextEnable, &out.PublicSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslSSLAddress != nil {
		in, out := &in.PublicSaslSSLAddress, &out.PublicSaslSSLAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslSSLDomainName != nil {
		in, out := &in.PublicSaslSSLDomainName, &out.PublicSaslSSLDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslSSLEnable != nil {
		in, out := &in.PublicSaslSSLEnable, &out.PublicSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolObservation.
func (in *PortProtocolObservation) DeepCopy() *PortProtocolObservation {
	if in == nil {
		return nil
	}
	out := new(PortProtocolObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolParameters) DeepCopyInto(out *PortProtocolParameters) {
	*out = *in
	if in.PrivatePlainEnable != nil {
		in, out := &in.PrivatePlainEnable, &out.PrivatePlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslPlaintextEnable != nil {
		in, out := &in.PrivateSaslPlaintextEnable, &out.PrivateSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslSSLEnable != nil {
		in, out := &in.PrivateSaslSSLEnable, &out.PrivateSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicPlainEnable != nil {
		in, out := &in.PublicPlainEnable, &out.PublicPlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslPlaintextEnable != nil {
		in, out := &in.PublicSaslPlaintextEnable, &out.PublicSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslSSLEnable != nil {
		in, out := &in.PublicSaslSSLEnable, &out.PublicSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolParameters.
func (in *PortProtocolParameters) DeepCopy() *PortProtocolParameters {
	if in == nil {
		return nil
	}
	out := new(PortProtocolParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolsInitParameters) DeepCopyInto(out *PortProtocolsInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolsInitParameters.
func (in *PortProtocolsInitParameters) DeepCopy() *PortProtocolsInitParameters {
	if in == nil {
		return nil
	}
	out := new(PortProtocolsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolsObservation) DeepCopyInto(out *PortProtocolsObservation) {
	*out = *in
	if in.PrivatePlainAddress != nil {
		in, out := &in.PrivatePlainAddress, &out.PrivatePlainAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivatePlainDomainName != nil {
		in, out := &in.PrivatePlainDomainName, &out.PrivatePlainDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivatePlainEnable != nil {
		in, out := &in.PrivatePlainEnable, &out.PrivatePlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslPlaintextAddress != nil {
		in, out := &in.PrivateSaslPlaintextAddress, &out.PrivateSaslPlaintextAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslPlaintextDomainName != nil {
		in, out := &in.PrivateSaslPlaintextDomainName, &out.PrivateSaslPlaintextDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslPlaintextEnable != nil {
		in, out := &in.PrivateSaslPlaintextEnable, &out.PrivateSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PrivateSaslSSLAddress != nil {
		in, out := &in.PrivateSaslSSLAddress, &out.PrivateSaslSSLAddress
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslSSLDomainName != nil {
		in, out := &in.PrivateSaslSSLDomainName, &out.PrivateSaslSSLDomainName
		*out = new(string)
		**out = **in
	}
	if in.PrivateSaslSSLEnable != nil {
		in, out := &in.PrivateSaslSSLEnable, &out.PrivateSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicPlainAddress != nil {
		in, out := &in.PublicPlainAddress, &out.PublicPlainAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicPlainDomainName != nil {
		in, out := &in.PublicPlainDomainName, &out.PublicPlainDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicPlainEnable != nil {
		in, out := &in.PublicPlainEnable, &out.PublicPlainEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslPlaintextAddress != nil {
		in, out := &in.PublicSaslPlaintextAddress, &out.PublicSaslPlaintextAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslPlaintextDomainName != nil {
		in, out := &in.PublicSaslPlaintextDomainName, &out.PublicSaslPlaintextDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslPlaintextEnable != nil {
		in, out := &in.PublicSaslPlaintextEnable, &out.PublicSaslPlaintextEnable
		*out = new(bool)
		**out = **in
	}
	if in.PublicSaslSSLAddress != nil {
		in, out := &in.PublicSaslSSLAddress, &out.PublicSaslSSLAddress
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslSSLDomainName != nil {
		in, out := &in.PublicSaslSSLDomainName, &out.PublicSaslSSLDomainName
		*out = new(string)
		**out = **in
	}
	if in.PublicSaslSSLEnable != nil {
		in, out := &in.PublicSaslSSLEnable, &out.PublicSaslSSLEnable
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolsObservation.
func (in *PortProtocolsObservation) DeepCopy() *PortProtocolsObservation {
	if in == nil {
		return nil
	}
	out := new(PortProtocolsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PortProtocolsParameters) DeepCopyInto(out *PortProtocolsParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PortProtocolsParameters.
func (in *PortProtocolsParameters) DeepCopy() *PortProtocolsParameters {
	if in == nil {
		return nil
	}
	out := new(PortProtocolsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PropertyListInitParameters) DeepCopyInto(out *PropertyListInitParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PropertyListInitParameters.
func (in *PropertyListInitParameters) DeepCopy() *PropertyListInitParameters {
	if in == nil {
		return nil
	}
	out := new(PropertyListInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PropertyListObservation) DeepCopyInto(out *PropertyListObservation) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PropertyListObservation.
func (in *PropertyListObservation) DeepCopy() *PropertyListObservation {
	if in == nil {
		return nil
	}
	out := new(PropertyListObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PropertyListParameters) DeepCopyInto(out *PropertyListParameters) {
	*out = *in
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Value != nil {
		in, out := &in.Value, &out.Value
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PropertyListParameters.
func (in *PropertyListParameters) DeepCopy() *PropertyListParameters {
	if in == nil {
		return nil
	}
	out := new(PropertyListParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReassignmentsInitParameters) DeepCopyInto(out *ReassignmentsInitParameters) {
	*out = *in
	if in.Assignment != nil {
		in, out := &in.Assignment, &out.Assignment
		*out = make([]AssignmentInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReassignmentsInitParameters.
func (in *ReassignmentsInitParameters) DeepCopy() *ReassignmentsInitParameters {
	if in == nil {
		return nil
	}
	out := new(ReassignmentsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReassignmentsObservation) DeepCopyInto(out *ReassignmentsObservation) {
	*out = *in
	if in.Assignment != nil {
		in, out := &in.Assignment, &out.Assignment
		*out = make([]AssignmentObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReassignmentsObservation.
func (in *ReassignmentsObservation) DeepCopy() *ReassignmentsObservation {
	if in == nil {
		return nil
	}
	out := new(ReassignmentsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReassignmentsParameters) DeepCopyInto(out *ReassignmentsParameters) {
	*out = *in
	if in.Assignment != nil {
		in, out := &in.Assignment, &out.Assignment
		*out = make([]AssignmentParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Brokers != nil {
		in, out := &in.Brokers, &out.Brokers
		*out = make([]*float64, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(float64)
				**out = **in
			}
		}
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.Topic != nil {
		in, out := &in.Topic, &out.Topic
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReassignmentsParameters.
func (in *ReassignmentsParameters) DeepCopy() *ReassignmentsParameters {
	if in == nil {
		return nil
	}
	out := new(ReassignmentsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResultInitParameters) DeepCopyInto(out *ResultInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResultInitParameters.
func (in *ResultInitParameters) DeepCopy() *ResultInitParameters {
	if in == nil {
		return nil
	}
	out := new(ResultInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResultObservation) DeepCopyInto(out *ResultObservation) {
	*out = *in
	if in.ErrorCode != nil {
		in, out := &in.ErrorCode, &out.ErrorCode
		*out = new(string)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.Success != nil {
		in, out := &in.Success, &out.Success
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResultObservation.
func (in *ResultObservation) DeepCopy() *ResultObservation {
	if in == nil {
		return nil
	}
	out := new(ResultObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ResultParameters) DeepCopyInto(out *ResultParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ResultParameters.
func (in *ResultParameters) DeepCopy() *ResultParameters {
	if in == nil {
		return nil
	}
	out := new(ResultParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SourceTaskInitParameters) DeepCopyInto(out *SourceTaskInitParameters) {
	*out = *in
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentInstanceAlias != nil {
		in, out := &in.CurrentInstanceAlias, &out.CurrentInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PeerInstanceAddress != nil {
		in, out := &in.PeerInstanceAddress, &out.PeerInstanceAddress
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.PeerInstanceAlias != nil {
		in, out := &in.PeerInstanceAlias, &out.PeerInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.PeerInstanceID != nil {
		in, out := &in.PeerInstanceID, &out.PeerInstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SourceTaskInitParameters.
func (in *SourceTaskInitParameters) DeepCopy() *SourceTaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(SourceTaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SourceTaskObservation) DeepCopyInto(out *SourceTaskObservation) {
	*out = *in
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentInstanceAlias != nil {
		in, out := &in.CurrentInstanceAlias, &out.CurrentInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.PeerInstanceAddress != nil {
		in, out := &in.PeerInstanceAddress, &out.PeerInstanceAddress
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.PeerInstanceAlias != nil {
		in, out := &in.PeerInstanceAlias, &out.PeerInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.PeerInstanceID != nil {
		in, out := &in.PeerInstanceID, &out.PeerInstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SourceTaskObservation.
func (in *SourceTaskObservation) DeepCopy() *SourceTaskObservation {
	if in == nil {
		return nil
	}
	out := new(SourceTaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SourceTaskParameters) DeepCopyInto(out *SourceTaskParameters) {
	*out = *in
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentInstanceAlias != nil {
		in, out := &in.CurrentInstanceAlias, &out.CurrentInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PeerInstanceAddress != nil {
		in, out := &in.PeerInstanceAddress, &out.PeerInstanceAddress
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.PeerInstanceAlias != nil {
		in, out := &in.PeerInstanceAlias, &out.PeerInstanceAlias
		*out = new(string)
		**out = **in
	}
	if in.PeerInstanceID != nil {
		in, out := &in.PeerInstanceID, &out.PeerInstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SourceTaskParameters.
func (in *SourceTaskParameters) DeepCopy() *SourceTaskParameters {
	if in == nil {
		return nil
	}
	out := new(SourceTaskParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaskInitParameters) DeepCopyInto(out *TaskInitParameters) {
	*out = *in
	if in.BootstrapServers != nil {
		in, out := &in.BootstrapServers, &out.BootstrapServers
		*out = new(string)
		**out = **in
	}
	if in.ClusterName != nil {
		in, out := &in.ClusterName, &out.ClusterName
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentClusterName != nil {
		in, out := &in.CurrentClusterName, &out.CurrentClusterName
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaskInitParameters.
func (in *TaskInitParameters) DeepCopy() *TaskInitParameters {
	if in == nil {
		return nil
	}
	out := new(TaskInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaskObservation) DeepCopyInto(out *TaskObservation) {
	*out = *in
	if in.BootstrapServers != nil {
		in, out := &in.BootstrapServers, &out.BootstrapServers
		*out = new(string)
		**out = **in
	}
	if in.ClusterName != nil {
		in, out := &in.ClusterName, &out.ClusterName
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentClusterName != nil {
		in, out := &in.CurrentClusterName, &out.CurrentClusterName
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaskObservation.
func (in *TaskObservation) DeepCopy() *TaskObservation {
	if in == nil {
		return nil
	}
	out := new(TaskObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TaskParameters) DeepCopyInto(out *TaskParameters) {
	*out = *in
	if in.BootstrapServers != nil {
		in, out := &in.BootstrapServers, &out.BootstrapServers
		*out = new(string)
		**out = **in
	}
	if in.ClusterName != nil {
		in, out := &in.ClusterName, &out.ClusterName
		*out = new(string)
		**out = **in
	}
	if in.CompressionType != nil {
		in, out := &in.CompressionType, &out.CompressionType
		*out = new(string)
		**out = **in
	}
	if in.ConsumerStrategy != nil {
		in, out := &in.ConsumerStrategy, &out.ConsumerStrategy
		*out = new(string)
		**out = **in
	}
	if in.CurrentClusterName != nil {
		in, out := &in.CurrentClusterName, &out.CurrentClusterName
		*out = new(string)
		**out = **in
	}
	if in.Direction != nil {
		in, out := &in.Direction, &out.Direction
		*out = new(string)
		**out = **in
	}
	if in.InstanceID != nil {
		in, out := &in.InstanceID, &out.InstanceID
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.ProvenanceHeaderEnabled != nil {
		in, out := &in.ProvenanceHeaderEnabled, &out.ProvenanceHeaderEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RenameTopicEnabled != nil {
		in, out := &in.RenameTopicEnabled, &out.RenameTopicEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicationFactor != nil {
		in, out := &in.ReplicationFactor, &out.ReplicationFactor
		*out = new(float64)
		**out = **in
	}
	if in.SaslMechanism != nil {
		in, out := &in.SaslMechanism, &out.SaslMechanism
		*out = new(string)
		**out = **in
	}
	if in.SecurityProtocol != nil {
		in, out := &in.SecurityProtocol, &out.SecurityProtocol
		*out = new(string)
		**out = **in
	}
	if in.SyncConsumerOffsetsEnabled != nil {
		in, out := &in.SyncConsumerOffsetsEnabled, &out.SyncConsumerOffsetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.TaskNum != nil {
		in, out := &in.TaskNum, &out.TaskNum
		*out = new(float64)
		**out = **in
	}
	if in.TopicsMapping != nil {
		in, out := &in.TopicsMapping, &out.TopicsMapping
		*out = new(string)
		**out = **in
	}
	if in.UserName != nil {
		in, out := &in.UserName, &out.UserName
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TaskParameters.
func (in *TaskParameters) DeepCopy() *TaskParameters {
	if in == nil {
		return nil
	}
	out := new(TaskParameters)
	in.DeepCopyInto(out)
	return out
}
